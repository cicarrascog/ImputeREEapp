[{"name":"app.R","content":"options(scipen = 100000)\r\nlibrary(shiny)\r\nlibrary(thematic)\r\nlibrary(plotly)\r\nlibrary(tidyverse)\r\nlibrary(imputeREE)\r\nlibrary(reactable)\r\nlibrary(reactablefmtr)\r\nlibrary(markdown)\r\nlibrary(bslib)\r\n\r\n\r\n\r\n\r\n`%notin%` <- Negate(`%in%`)\r\n\r\ncard_Welcome1<- card(\r\n  card_header(HTML(\"<h2>Instructions<\/h2>\")),\r\n  full_screen = F,\r\n  includeMarkdown(\"Instructions_card1.md\"))\r\ncard_Welcome2<- card(\r\n  card_header(html(\"<h2>Quick Start (tl;dr)<\/h2>\")),\r\n  full_screen = F,\r\n  includeMarkdown(\"Instructions_card2.md\"))\r\n\r\ncard_References <- card(\r\n  # card_header(\"Welcome\"),\r\n  full_screen = TRUE,\r\n  includeMarkdown(\"Reference.md\"))\r\ncard_changelog <- card(\r\n  # card_header(\"Welcome\"),\r\n  full_screen = TRUE,\r\n  includeMarkdown(\"Changelog.md\"))\r\ncard_license <- card(\r\n  # card_header(\"Welcome\"),\r\n  full_screen = TRUE,\r\n  includeMarkdown(\"license.md\"))\r\ncard_contact <- card(\r\n  # card_header(\"Welcome\"),\r\n  full_screen = TRUE,\r\n  includeMarkdown(\"Contact.md\"))\r\n\r\n\r\n### Upload Tab\r\n\r\ncard_fileupload <- card( #--------------\r\n  # card_header(\"File upload\") ,\r\n  fileInput(\r\n    inputId = \"newFile\",\r\n    label = NULL,\r\n    accept = c(\".csv\"),\r\n    buttonLabel = \"Upload...\",\r\n    placeholder = \"a .csv file\"\r\n  ),\r\n  radioButtons(\r\n    inputId = \"chondrite_values\",\r\n    label = \"Chondrite Values\",\r\n    choices = c(\r\n      `Palme and O'Neill (2014)` = \"PalmeOneill2014CI\",\r\n      `McDonough and Sun (1995)` = \"McDonough1995CI\"\r\n    )\r\n  )\r\n)\r\n\r\ncard_model_Settings <- card(# model settings --------------\r\n\r\n\r\n    textOutput(\"Rees\"),\r\n    checkboxGroupInput(\r\n      inputId = \"NormalizeMethod\",\r\n      label = \"Chondrite Values\",\r\n      inline = T,\r\n      choices = REE_plus_Y_Elements,\r\n      selected = REE_plus_Y_Elements[REE_plus_Y_Elements %notin%\r\n                                       c(\"La\", \"Ce\", \"Pr\", \"Eu\", \"Y\")]\r\n    )\r\n\r\n)\r\n\r\ncard_model_Settings2 <- card(# model settings --------------\r\nradioButtons(\r\n  inputId = \"method\",\r\n  label = \"Method\",\r\n  choices = c(\r\n    `Chondrite-Onuma` = 3,\r\n    `Chondrite-Lattice` = 1,\r\n    `Zhong et al. (2019)` = 2\r\n  )))\r\n\r\n\r\ncard_r2_histogram <- card(##r2 histogram--------------\r\n  card_header(HTML(\"R<sup>2<\/sup> histogram\")),\r\n    layout_sidebar(\r\n    sidebar = sidebar(\r\n      title = 'Plot Settings',\r\n      position = \"right\",\r\n      sliderInput(\r\n        inputId = \"reference_line_R2\",\r\n        label = \"Reference Line\",\r\n        value = 0.95,\r\n        min = 0.5,\r\n        max = 0.999,\r\n        step = 0.005\r\n      ),\r\n      checkboxInput(\r\n        inputId = \"hide_reference_line\",\r\n        label = \"Hide line\"\r\n      ),\r\n      checkboxInput(\r\n        inputId = \"AdjustedR2\",\r\n        label = \"Use adjusted R2\"\r\n      )\r\n    ),\r\n    plotOutput(\"R2_plot\")\r\n   ))\r\n\r\n\r\ncard_boxplot <- card(## card_boxplot--------------\r\n  card_header(\"Ratio Boxplot\"),\r\n    layout_sidebar(\r\n\r\n    sidebar = sidebar(\r\n      title = 'Plot Settings',\r\n      position = \"right\",\r\n      open = 'desktop',\r\n      sliderInput(\r\n      inputId = \"rsquared_filter\",\r\n      label = \"R squared filter\",\r\n      value = 0.9,\r\n      min = 0,\r\n      max = 2,\r\n      step = 0.001\r\n    )),\r\n    plotOutput(\"ratio_plot\")\r\n  )\r\n  )\r\n\r\ncard_summstats <- card( ## card_summstats-------------\r\n  card_header(HTML(\"Summary statistics\")),max_height = '30%',\r\n  reactableOutput(\"ratio_table\")\r\n)\r\n\r\n\r\n\r\n# Data Tab--------------\r\ncard_Reactable <- card(##card_Reactable-----------------\r\n                       full_screen = T,fill = T,\r\n  reactableOutput(\"Result\")\r\n)\r\n\r\ncard_REE_plot <- card(##card_REE_plot-------------\r\n  max_height = '350',\r\n                      card_header('Chondrite-Normalized pattern'),\r\n  layout_sidebar(\r\n    sidebar = sidebar(\r\n      title = 'Plot Settings',\r\n      position = \"right\",\r\n      checkboxInput(inputId = \"strain\", label = \"Use misfit expression?\", value = F),\r\n      checkboxInput(inputId = \"complete_lines\", label = \"Complete pattern when data is missing?\", value = F),\r\n      checkboxInput(inputId = \"hide_original\", label = \"Hide Original\", value = F),\r\n      checkboxInput(inputId = \"hide_calculated\", label = \"Hide Calculated\", value = F),\r\n      checkboxInput(inputId = \"hide_legend\", label = \"Hide Legend\", value = F),\r\n      shiny::numericInput(inputId = \"min_plot_value\", value = NULL, label = \"min y axis\"),\r\n      shiny::numericInput(inputId = \"max_plot_value\", value = NULL, label = \"max y axis\")),\r\n    plotOutput(\"REE_plot\")\r\n  )\r\n)\r\n\r\n\r\ncard_scatterplot_plotly <-card(##card_scatterplot_plotly-------------\r\n  max_height = '400',\r\n                               card_header('Scatterplot'),\r\n                                layout_sidebar(\r\n                                  sidebar = sidebar(\r\n                                    title = 'Plot Settings',\r\n                                    position = \"right\",\r\n                                    uiOutput(\"scatterycol\"),\r\n                                    uiOutput(\"scatterxcol\"),\r\n                                    checkboxInput(inputId = \"scatter_log_y\", label = \"log y\", value = F),\r\n                                    checkboxInput(inputId = \"scatter_log_x\", label = \"log x\", value = T),\r\n                                      #\r\n                                    ),\r\n                                  plotly::plotlyOutput(\"scatterplot\"),\r\n\r\n                                  ))\r\n\r\n\r\n# Downliad Tab =========================\r\n\r\n\r\ncard_Download_settings <- card( ## card_Download_settings ======\r\n\r\n  card_header(HTML(\"<h4>Impute Values?<\/h4>\")),\r\n  markdown(\"Ticking this option will add a column for each REE in the format `Imputed_[REEname]`,\r\n             where missing values are replaced for those calculated from the model. Measured values are kept.\"),\r\n  markdown(\"The slider allows to set a threshold for imputation so models with R<sup>2<\/sup> lower than the threshold are not imputed\"),\r\n  HTML(\"Check important info in the welcome tab for more details.\"),\r\n  sliderInput(inputId = \"R_filter_export\", label = HTML(\"R<sup>2<\/sup> filter\"), value = 0.99, min = 0.9, max = 1, step = 0.001),\r\n  checkboxInput(\r\n    inputId = \"impute\",\r\n    label = \"Impute?\",\r\n    value = FALSE\r\n  )\r\n)\r\n\r\n\r\ncard_include_norm <- card(\r\n  card_header(HTML(\"<h4>Include Chondrite nomalized values?<\/h4>\")),\r\n\r\n  markdown(\"Ticking this option will add a column for each REE in the format `[REEname]_Normalized` and `NormalizedCalc_[REEname]` to include the Chondrite normalized values using measured and calculated concentrations, respectively.\"),\r\n  checkboxInput(\r\n    inputId = \"include_norm_values\",\r\n    label = \"Include Chondrite Normalized Values?\",\r\n    value = FALSE)\r\n)\r\n\r\n\r\n  Download_card <- card(\r\n    markdown('**Download Info**'),\r\n    markdown('Ce/Ce* and Eu/Eu* are calculaded using Ce* from the regression models (ppmCalc_Ce and ppmCalc_Eu, respectively).'),\r\n    markdown('If the Chondrite-Lattice method is used, Intercept and slope are returned.'),\r\n    markdown('If the Chondrite-Onuma method is used, parabola parameters (a,b, and intercept) are returned.'),\r\n    markdown('Columns starting with `ppmCalc_` are calculated values in ppm.'),\r\n    markdown('Columns starting with `NormalizedCalc_` are calculated chondrite-normalized values'),\r\n    markdown('Columns starting with `Ratio_` are ratio between calculated and measured values (not applicable when data are missing).'),\r\n    markdown(\"**Click below to download**\"),\r\n    downloadButton(outputId = \"donwload_data\")\r\n  )\r\n\r\nui <- page_navbar( # UI ----------\r\n\r\n  theme = bs_theme(),\r\n  title = \"imputeREEapp\",\r\n  gap = validateCssUnit(5) ,\r\n  padding = validateCssUnit(5) ,\r\n  fillable = T,\r\n  # sidebar = color_by,\r\n  nav_panel(title = 'Welcome',\r\n            includeMarkdown(\"Instructions.md\"),\r\n            layout_columns(card_Welcome2, card_Welcome1)),\r\n  nav_panel(title = \"Upload\",\r\n\r\n            layout_columns(card_fileupload, card_model_Settings,card_model_Settings2, gap = validateCssUnit(5), height = '30%'),\r\n            layout_columns(card_r2_histogram, card_boxplot, gap = validateCssUnit(5)),\r\n            card_summstats),\r\n  nav_panel(title = \"Data\",\r\n            bslib::layout_sidebar(\r\n              sidebar = sidebar(\r\n\r\n                card_REE_plot,\r\n                card_scatterplot_plotly,\r\n                width= validateCssUnit(\"45%\")),\r\n              reactableOutput(\"Result\", height = '100%'))),\r\n\r\n  nav_panel(title = \"Download\", page_sidebar(\r\n    card_Download_settings,\r\n    card_include_norm,\r\n    sidebar = sidebar(Download_card, open ='always', width = \"50%\"))),\r\n\r\n  nav_panel(title = \"References\", card_References),\r\n\r\n  nav_panel(title = \"Changelog\", card_changelog),\r\n\r\n  nav_panel(title = \"License\", card_license),\r\n\r\n  nav_panel(title = \"Contact\", card_contact),\r\n  nav_spacer(),\r\n  nav_item(\r\n    input_dark_mode(id = \"dark_mode\", mode = \"light\")\r\n  ))\r\n\r\n\r\n\r\n\r\n# server Section -----------\r\n# Define server logic required to draw a histogram\r\nserver <- function(input, output) {\r\nthematic::thematic_shiny(font = font_spec(scale = 1.5))\r\n\r\n\r\n\r\n\r\n    sample_data <- reactive({\r\n    Ballard_et_al_Zircon %>%\r\n      # slice(1:500) %>%\r\n      select(matches(paste0(\"Zr_\", REE_plus_Y_Elements, \"_ppm\")), Zr_P_ppm) %>%\r\n      rename_with(~ str_remove_all(.x, \"^Zr_|_ppm$\"))\r\n  })\r\n\r\n\r\n  ## Prepare Data ------\r\n\r\n  base_data <- reactive({\r\n    # req(input$newFile$datapath)\r\n\r\n\r\n    if (is.null(input$newFile)) {\r\n      data <- sample_data()\r\n    } else {\r\n      data <- read_csv(input$newFile$datapath)\r\n    }\r\n\r\n\r\n\r\n    REE_to_model <- REE_plus_Y_Elements[REE_plus_Y_Elements %notin% input$NormalizeMethod]\r\n    print(REE_to_model)\r\n\r\n\r\n    # data <- read_csv(input$newFile$datapath)\r\n\r\n    check_columns <- REE_plus_Y_Elements[REE_plus_Y_Elements %notin% names(data)]\r\n\r\n    if (length(check_columns > 0)) {\r\n      data[, check_columns] <- NA_real_\r\n      data <- data %>% relocate(REE_plus_Y_Elements)\r\n    }\r\n\r\n\r\n    normalized_data <- data %>% imputeREE:::Element_norm(chondrite = !!sym(input$chondrite_values))\r\n\r\n    ### Model Section Data ------\r\n    if (input$method == 1) {\r\n      withProgress(\r\n        message = \"Fitting Models\",\r\n        data <- data %>%\r\n          modelChondrite_lattice(.,\r\n                                 exclude = REE_to_model,\r\n                                 chondrite = !!sym(input$chondrite_values),\r\n                                 Calibrate = T\r\n          )\r\n      )\r\n    }\r\n\r\n    ### Here conditional for the three methods\r\n    withProgress(\r\n      message = \"Fitting Models\",\r\n      if (input$method == 2) {\r\n        data <- data %>%\r\n          modelZhong(.,\r\n                     exclude = REE_to_model,\r\n                     chondrite = !!sym(input$chondrite_values)\r\n          )\r\n      }\r\n    )\r\n\r\n    withProgress(\r\n      message = \"Fitting Models\",\r\n      if (input$method == 3) {\r\n        data <- data %>%\r\n          modelChondrite_Onuma(.,\r\n                               exclude = REE_to_model,\r\n                               chondrite = !!sym(input$chondrite_values),\r\n                               Calibrate = T\r\n          )\r\n      }\r\n    )\r\n\r\n\r\n    ### HERE A CONDITIONAL FOR CHONDRITE ONUMA METHOD\r\n\r\n    if (input$method == 3) {\r\n      complete_data <- left_join(data, normalized_data, by = \"rowid\") %>%\r\n        rename(\r\n          `R.squared` = model_r.squared,\r\n          `adj.R.squared` = model_adj.r.squared,\r\n          `Intercept` = estimate_Intercept,\r\n          `a (parabola)` = estimate_X1,\r\n          `b (parabola)` = estimate_X2\r\n        )\r\n    } else {\r\n      complete_data <- left_join(data, normalized_data, by = \"rowid\") %>%\r\n        rename(\r\n          `R.squared` = model_r.squared,\r\n          `adj.R.squared` = model_adj.r.squared,\r\n          `Intercept` = estimate_Intercept,\r\n          `Slope` = estimate_Slope\r\n        )\r\n    }\r\n\r\n\r\n\r\n\r\n    return(complete_data)\r\n  })\r\n\r\n\r\n\r\n  ## Apply Corrections  ------\r\n  # corrected_data <- reactive({\r\n  #   data <- base_data() %>%\r\n  #     imputeREE:::correct_heavy(\r\n  #       Y_correction_fact = input$Y,\r\n  #       Yb_correction_fact = input$Yb,\r\n  #       Lu_correction_fact = input$Lu,\r\n  #       Ho_correction_fact = input$Ho,\r\n  #       Er_correction_fact = input$Er,\r\n  #       Tm_correction_fact = input$Tm\r\n  #     ) %>%\r\n  #     imputeREE:::correct_middle(\r\n  #       Nd_correction_fact = input$Nd,\r\n  #       Sm_correction_fact = input$Sm,\r\n  #       Gd_correction_fact = input$Gd,\r\n  #       Tb_correction_fact = input$Tb,\r\n  #       Dy_correction_fact = input$Dy,\r\n  #       Pr_correction_fact = input$Pr\r\n  #     )\r\n\r\n  #   return(data)\r\n  # })\r\n\r\n  ##  Create long format with normalized values ----------------\r\n\r\n  norm_table <- reactive({\r\n    data <- base_data() %>%\r\n      select(rowid, `R.squared`, matches(\"Normalized\")) %>%\r\n      rename_with(.cols = matches(\"Normalized$\"), ~ paste0(\"Normalized_\", str_remove_all(.x, \"_Normalized$\"))) %>%\r\n      pivot_longer(cols = matches(\"Normalized\"), names_to = c(\".value\", \"Element_name\"), names_sep = \"_\") %>%\r\n      imputeREE:::add_IonicRadii() %>%\r\n      rename(`Ionic Radius` = ShannonRadiiVIII_Coord_3plus) %>%\r\n      mutate(Ratio = NormalizedCalc / Normalized)\r\n\r\n    data_long <- data %>%\r\n      select(-Ratio) %>%\r\n      pivot_longer(cols = c(\"NormalizedCalc\", \"Normalized\"), names_to = \"Data Type\", values_to = \"Chondrite Normalized\")\r\n    return(list(data_long, data))\r\n  })\r\n\r\n\r\n  ## This is the data used for the table that is shown in Data tab ----------------\r\n\r\n  modelled_data <- reactive({\r\n    data <- norm_table()[[2]] %>%\r\n      pivot_wider(id_cols = \"rowid\", names_from = \"Element_name\", names_prefix = \"Ratio_\", values_from = \"Ratio\")\r\n\r\n    ### HERE ANOTHER CONDITIONAL FOR METHOD\r\n\r\n    data <- left_join(base_data(), data, by = \"rowid\") %>%\r\n      mutate(\r\n        `Ce/Ce*` = Ce / ppmCalc_Ce,\r\n        `Eu/Eu*` = Eu / ppmCalc_Eu\r\n      ) %>%\r\n      relocate(\r\n        rowid, model_nree,\r\n        R.squared,\r\n        adj.R.squared,\r\n        matches(\"Intercept|Slope|(parabola)\"),\r\n        # Slope,\r\n        `Ce/Ce*`,\r\n        `Eu/Eu*`,\r\n        REE_plus_Y_Elements,\r\n        matches(\"_Normalized$\"), matches(\"^ppmCalc_\"), matches(\"^NormalizedCalc_\"), matches(\"^Ratio_\")\r\n      )\r\n  })\r\n\r\n\r\n  ## List of excluded REE ----------------\r\n  output$Rees <- renderText({\r\n    paste(\"Excluded from model:\", paste(\" \", REE_plus_Y_Elements[REE_plus_Y_Elements %notin% input$NormalizeMethod], collapse = \" , \"))\r\n  })\r\n  ## tables ----------------\r\n\r\n  ###  reactable for the results ##############\r\n\r\n  output$Result <- renderReactable({\r\n    data <- modelled_data()\r\n\r\n    if (input$include_norm_values == FALSE) {\r\n      data <- data %>% select(!matches(\"^NormalizedCalc|Normalized\"))\r\n    }\r\n\r\nif (input$dark_mode == 'dark') {\r\n  reactable(data %>% select(!matches(\"model_.+$|std.error_.+$|statistic_.+$|p.value_.+$\")),\r\n            # %>%  select(-dplyr::last_col(15):-last_col()),\r\n            defaultPageSize = 15,\r\n            resizable = T,\r\n            showPageSizeOptions = T,\r\n            defaultColDef = colDef(format = reactable::colFormat(digits = 3)),\r\n            columns = list(\r\n              rowid = colDef(name = \"ID\", format = colFormat(digits = 0))\r\n            ),\r\n            highlight = T,\r\n            onClick = \"select\",\r\n            selection = \"single\",\r\n            filterable = T,\r\n            defaultSelected = 1,\r\n            theme = reactablefmtr::slate())\r\n} else{\r\n    reactable(data %>% select(!matches(\"model_.+$|std.error_.+$|statistic_.+$|p.value_.+$\")),\r\n              # %>%  select(-dplyr::last_col(15):-last_col()),\r\n              defaultPageSize = 15,\r\n              resizable = T,\r\n              showPageSizeOptions = T,\r\n              defaultColDef = colDef(format = reactable::colFormat(digits = 3)),\r\n              columns = list(\r\n                rowid = colDef(name = \"ID\", format = colFormat(digits = 0))\r\n              ),\r\n              highlight = T,\r\n              onClick = \"select\",\r\n              selection = \"single\",\r\n              filterable = T,\r\n              defaultSelected = 1)}\r\n\r\n\r\n  })\r\n\r\n\r\n\r\n\r\n  output$ratio_table <- renderReactable({\r\n    data <- norm_table()[[2]] %>% arrange(desc(`Ionic Radius`))\r\n    data <- data %>%\r\n      select(Element_name, Ratio) %>%\r\n      group_by(Element_name) %>%\r\n      summarize(\r\n        mean = mean(Ratio, na.rm = T),\r\n        sd = sd(Ratio, na.rm = T),\r\n        median = median(Ratio, na.rm = T),\r\n        IQR = IQR(Ratio, na.rm = T),\r\n        MAD = mad(Ratio, na.rm = T)\r\n      ) %>%\r\n      imputeREE:::add_IonicRadii() %>%\r\n      arrange(desc(ShannonRadiiVIII_Coord_3plus)) %>%\r\n      select(-ShannonRadiiVIII_Coord_3plus)\r\nif (input$dark_mode == 'dark') {\r\n  reactable(data,\r\n\r\n            pagination = F,\r\n            highlight = T,\r\n            defaultColDef = colDef(format = reactable::colFormat(digits = 3)),\r\n            theme = reactablefmtr::dark()\r\n  )\r\n} else {\r\n  reactable(data,\r\n\r\n            pagination = F,\r\n            highlight = T,\r\n            defaultColDef = colDef(format = reactable::colFormat(digits = 3))\r\n  )\r\n\r\n}\r\n\r\n  })\r\n\r\n  # Plots ######\r\n\r\n  ### REE plot ##########\r\n\r\n  output$REE_plot <- renderPlot({\r\n    breaks <- imputeREE::Element_Data %>% filter(Element_name %in% REE_plus_Y_Elements)\r\n    labels <- breaks$Element_name\r\n    breaks <- breaks$ShannonRadiiVIII_Coord_3plus\r\n\r\n    req(getReactableState(\"Result\")$selected)\r\n\r\n    id_num <- getReactableState(\"Result\")$selected\r\n    data <- norm_table()[[1]]\r\n\r\n\r\n\r\n    if (input$hide_original) {\r\n      data <- data %>% filter(`Data Type` != \"Normalized\")\r\n    }\r\n    if (input$hide_calculated) {\r\n      data <- data %>% filter(`Data Type` != \"NormalizedCalc\")\r\n    }\r\n\r\n    if (input$complete_lines) {\r\n      data <- data %>% filter(!is.na(`Chondrite Normalized`))\r\n    }\r\n\r\n\r\n    if (input$strain) {\r\n      data <- data %>% mutate(`Ionic Radius` = (`Ionic Radius` / 3 + 0.84 / 6) * (`Ionic Radius` - 0.84)^2)\r\n      breaks <- (breaks / 3 + 0.84 / 6) * (breaks - 0.84)^2\r\n    }\r\n\r\n    data %>%\r\n      filter(rowid == id_num) %>%\r\n      ggplot(aes(x = `Ionic Radius`, y = `Chondrite Normalized`, group = `Data Type`, color = `Data Type`)) +\r\n      {\r\n        if (input$strain) xlab(\"ri/3 + r0/6)*(ri-r0)^2\")\r\n      } +\r\n      # theme_bw(base_size = 15) +\r\n      theme(\r\n        legend.position = c(0.95, 0.05),\r\n        legend.justification = c(0.95, 0.05)\r\n      ) +\r\n      {\r\n        if (input$hide_legend) theme(legend.position = \"none\")\r\n      } +\r\n      geom_point(size = 3) +\r\n      geom_line() +\r\n      scale_y_log10(minor_breaks = NULL\r\n\r\n        # labels = scales::label_number(accuracy = 0.00001)\r\n      ) +\r\n      scale_x_reverse(breaks = breaks, labels = labels, minor_breaks = NULL) +\r\n      scale_color_viridis_d(labels = c('Measured','Calculated')) +\r\n      annotation_logticks(sides = 'l') +\r\n      coord_cartesian(ylim = c(input$min_plot_value, input$max_plot_value))\r\n  })\r\n\r\n\r\n\r\n  ### scatterpot ##########\r\n\r\n  output$scatterxcol <- renderUI({\r\n    data <- modelled_data()\r\n\r\n    if (input$include_norm_values == FALSE) {\r\n      data <- data %>% select(!matches(\"^NormalizedCalc|Normalized\"))\r\n    }\r\n    data <- data %>%\r\n      select(!matches(\"model_.+$|std.error_.+$|statistic_.+$|p.value_.+$\")) %>%\r\n      select(where(is.numeric))\r\n\r\n\r\n    choices <- names(data)\r\n\r\n    selectInput(\"xcol\", \"X Variable\", choices = choices, selected = \"La\", multiple = F, selectize = T)\r\n  })\r\n\r\n  output$scatterycol <- renderUI({\r\n    data <- modelled_data()\r\n\r\n    if (input$include_norm_values == FALSE) {\r\n      data <- data %>% select(!matches(\"^NormalizedCalc|Normalized\"))\r\n    }\r\n    data <- data %>%\r\n      select(!matches(\"model_.+$|std.error_.+$|statistic_.+$|p.value_.+$\")) %>%\r\n      select(where(is.numeric))\r\n\r\n\r\n    choices <- names(data)\r\n\r\n    selectInput(\"ycol\", \"Y Variable\", choices = choices, selected = \"Pr\", multiple = F, selectize = T)\r\n  })\r\n\r\n\r\n\r\n\r\n  output$scatterplot <- plotly::renderPlotly({\r\n    req(modelled_data())\r\n    data <- modelled_data()\r\n\r\n    if (input$include_norm_values == FALSE) {\r\n      data <- data %>% select(!matches(\"^NormalizedCalc|Normalized\"))\r\n    }\r\n\r\n    data <- data %>% select(!matches(\"model_.+$|std.error_.+$|statistic_.+$|p.value_.+$\"))\r\n\r\n\r\n    fig <- plotly::plot_ly(data, x = ~.data[[input$xcol]], y = ~.data[[input$ycol]], text = ~paste('ID:',.data[['rowid']]))\r\n\r\n\r\n    fig <- fig %>%  plotly::layout(xaxis = list(title = as.character(input$xcol)),\r\n                            yaxis = list(title = as.character(input$ycol)))\r\n\r\n\r\n    #\r\n\r\n    if (input$scatter_log_x) {\r\n      fig <- fig %>%  plotly::layout( xaxis = list(type = \"log\"))\r\n    }\r\n    if (input$scatter_log_y) {\r\n      fig <- fig %>%  plotly::layout( yaxis = list(type = \"log\"))\r\n    }\r\n    ## this is the dark mode for plotly ----------------\r\n    if(input$dark_mode=='dark'){\r\n    fig <- fig %>% plotly::layout(plot_bgcolor = '#444', paper_bgcolor = '#303030', font = list(color = 'white'), xaxis = list(gridcolor = '#303030'),yaxis = list(gridcolor = '#303030'))} else {fig}\r\n  })\r\n\r\n\r\n  ### Rsquared Histogram #########\r\n  output$R2_plot <- renderPlot({\r\n    var <- \"R.squared\"\r\n    if (input$AdjustedR2) {\r\n      var <- \"adj.R.squared\"\r\n    }\r\n\r\n\r\n    modelled_data() %>%\r\n      ggplot(aes_string(var)) +\r\n      geom_histogram() +\r\n      {\r\n        if (!input$hide_reference_line) geom_vline(xintercept = input$reference_line_R2)\r\n      } +\r\n      scale_x_continuous(trans = \"logit\", breaks = c(0.5, 0.9, 0.95, 0.99, 0.999))\r\n  })\r\n\r\n\r\n  ### Ratio_plots ###########\r\n  output$ratio_plot <- renderPlot({\r\n    breaks <- imputeREE::Element_Data %>% filter(Element_name %in% REE_plus_Y_Elements)\r\n    labels <- breaks$Element_name\r\n    breaks <- breaks$ShannonRadiiVIII_Coord_3plus\r\n\r\n\r\n\r\n\r\n    norm_table()[[2]] %>%\r\n      filter(R.squared > input$rsquared_filter) %>%\r\n      # filter(Element_name %in% REE_Elements[-c(1,2,3,6)]) %>%\r\n      arrange(desc(`Ionic Radius`)) %>%\r\n      ggplot(aes(y = Ratio, x = forcats::fct_inorder(Element_name))) +\r\n      geom_boxplot(\r\n        # aes(fill = forcats::fct_inorder(Element_name))\r\n      ) +\r\n      xlab(\"Element\") +\r\n      geom_hline(yintercept = 1, lty = 2, alpha = 0.8) +\r\n      # scale_fill_viridis_d() +\r\n      theme(legend.position = \"none\") +\r\n      scale_y_log10(\r\n        # labels = scales::label_number(accuracy = 0.00001)\r\n      )\r\n  })\r\n\r\n\r\n  download_data <- reactive({\r\n    data <- modelled_data()\r\n    data <-data %>%  mutate(model_r.squared = R.squared)\r\n\r\n    if (input$include_norm_values == FALSE) {\r\n      data <- data %>% select(!matches(\"^NormalizedCalc|Normalized\"))\r\n    }\r\n    if (input$impute) {\r\n      data <- data %>% impute_REE(rsquared = input$R_filter_export)\r\n      data <- data %>%  select(-model_r.squared)\r\n       }\r\n    data <- data %>% select(!matches(\"model_.+$|std.error_.+$|statistic_.+$|p.value_.+$\"))\r\n    return(data)\r\n  })\r\n\r\n  #### downloads ####\r\n\r\n  output$donwload_data <- downloadHandler(\r\n    filename = function() {\r\n      paste0(input$dataset, \"calc.csv\")\r\n    },\r\n    content = function(file) {\r\n      write.csv(download_data(), file)\r\n    }\r\n  )\r\n}\r\n\r\n# Run the application\r\nshinyApp(ui = ui, server = server)\r\n","type":"text"},{"name":"Changelog.md","content":"\r\n# Changelog\r\n\r\n2022/07/18 Pre-release version\r\n\r\n2022/09/08 Repository made public\r\n\r\n2023/06/23\r\n\r\n- References added\r\n- App now apply three difference methods: Chondrite-Lattice,\r\n  Chondrite-Onuma and Zhong et al., 2019.\r\n\r\n29/06/2023\r\n\r\n- Change to `bslib`\r\n\r\n22/12/2023\r\n\r\n- base theme changed\r\n- added a light-dark mode switch\r\n","type":"text"},{"name":"Contact.md","content":"\r\n# Contact\r\n\r\nCreator: Carlos Carrasco-Godoy Github: <https://github.com/cicarrascog>\r\n\r\n- App repository: <https://github.com/cicarrascog/ImputeREEapp>\r\n- imputeREE repository: <https://github.com/cicarrascog/ImputeREE>\r\n\r\nIf you have any question or find any bug please raise an issue on github\r\nor email me to: <carlos.carrasco@anu.edu.au> or <ccarrasco@outlook.cl>\r\n","type":"text"},{"name":"Instructions.md","content":"\r\n# ImputeREEapp\r\n\r\nThis is a companion app in development for the [imputeREE package for\r\nR](https://github.com/cicarrascog/imputeREE). It allows the imputation\r\nof missing REE data and calculates Ce and Eu anomalies on magmatic\r\nzircon based on the Chondrite-Onuma and Chondrite-Lattice methods of\r\n[Carrasco-Godoy and Campbell\r\n(2023)](https://link.springer.com/article/10.1007/s00410-023-02025-9)\r\nand the logarithmic regression from [Zhong et al.\r\n(2019)](https://link.springer.com/article/10.1007/s00710-019-00682-y).\r\n\r\nAt the top, it is possible to access the different sections of the app.\r\nA general description of each section is included here.\r\n\r\nCreator: [Carlos Carrasco-Godoy](https://github.com/cicarrascog)\r\n","type":"text"},{"name":"Instructions_card1.md","content":"\r\n### Upload Tab\r\n\r\nIn this section, you can upload your data in .csv format. The example\r\ndata, which are zircons from [Ballard et al.\r\n(2002)](http://link.springer.com/10.1007/s00410-002-0402-5), are\r\nautomatically loaded.\r\n\r\nPlease use the upload button to load your data. The column names of the\r\nREE should include only the element name in ppm (e.g., `La`, not\r\n`La_ppm`). **Large files will take longer to process**.\r\n\r\nAny additional column will be added at the end of the table. A column\r\nwith the name `rowid` is likely to give an error, please rename or\r\nexclude this column.\r\n\r\nThe chondrite values selector allows to choose the reference of those\r\nvalues. Only those from [Palme and O’Neill\r\n(2014)](http://www.sciencedirect.com/science/article/pii/B9780080959757002011)\r\nand [McDonough and Sun\r\n(1995)](http://www.sciencedirect.com/science/article/pii/0009254194001404)\r\nare included in this version.\r\n\r\nIn the model variables panel, you can choose the REE that will be used\r\nfor fitting the model. However, La, Pr, Eu, Ce and Y are automatically\r\ndeselected as they do not fit the regression and their inclusion would\r\nnegatively affect the model fit.\r\n\r\nThe R<sup>2<\/sup> plot shows the distribution of the R-squared statistic\r\nfor each model (one model per zircon grain).\r\n\r\nThe boxplots show the ratios between the calculated and the measured\r\nvalues for each element. The horizontal line is a reference for ratio =\r\n1.\r\n\r\nThe last panel is a table with summary statistics of the ratio between\r\ncalculated and measured data.\r\n\r\n### Data\r\n\r\nThis feature enables individual exploration of the data. On the right\r\nside, there is a table that displays the uploaded data, along with the\r\ncalculated values and model measurements such as R-squared, slope,\r\nintercept, or parabola parameters. It also shows the calculated\r\nconcentrations and the ratio of calculated to measured values. Clicking\r\non any row in the table will display the REE pattern and its\r\ncorresponding values in the left panels.\r\n\r\nIf necessary, you can utilize an interactive scatterplot to examine your\r\ndata. By hovering over the dots, the ID can be displayed, allowing you\r\nto filter it in the table.\r\n\r\n### Download\r\n\r\nOn this tab, you can download your data once the calculations are\r\ncomplete.\r\n","type":"text"},{"name":"Instructions_card2.md","content":"\r\nUse the upload tab to load your data, then the download tab to obtain\r\nthe results.\r\n\r\n### Important\r\n\r\nThe coefficient of determination of each model gives an idea of how well\r\nthe model fits the data. However, it is important to consider that\r\nR<sup>2<\/sup> values will be higher for the Chondrite-Onuma, which is\r\nbased on quadratic regression, than for the Chondrite-Lattice method.\r\n\r\nFor the Chondrite-Onuma, the parameter `a (parabola)` can be as an\r\nadditional measure of confidence. Zircon REE patterns are not upward\r\nconcave.\r\n","type":"text"},{"name":"Reference.md","content":"\r\n# Citation\r\n\r\nPlease cite [Carrasco-Godoy and Campbell, 2023, Contributions to\r\nMineralogy and\r\nPetrology](https://link.springer.com/article/10.1007/s00410-023-02025-9)\r\nif you use this app in you research.\r\n\r\nPlease cite [Zhong et al., Mineralogy and\r\nPetrology](https://link.springer.com/article/10.1007/s00710-019-00682-y)\r\nif you apply their method.\r\n\r\n# Code\r\n\r\nThe models are constructed using the [`imputeREE`\r\npackage](https://cran.r-project.org/web/packages/imputeREE/index.html)\r\nand app is built using: [`bslib`](https://github.com/rstudio/bslib),\r\n[`markdown`](https://cran.r-project.org/web/packages/markdown/index.html),\r\n[`plotly`](https://plotly.com/),\r\n[`reactable`](https://github.com/glin/reactable),\r\n[`reactablefmtr`](https://github.com/kcuilla/reactablefmtr/) ,\r\n[`shiny`](https://github.com/rstudio/shiny),\r\n[`thematic`](https://rstudio.github.io/thematic/) and\r\n[`tidyverse`](https://www.tidyverse.org/)\r\n\r\nCode can be found here:\r\n\r\n- App repository: <https://github.com/cicarrascog/ImputeREEapp>\r\n\r\n- imputeREE repository: <https://github.com/cicarrascog/ImputeREE>\r\n\r\n# References\r\n\r\n[Shannon, R. D., 1976, Revised effective ionic radii and systematic\r\nstudies of interatomic distances in halides and chalcogenides: Acta\r\nCrystallographica Section A, v. 32, p.\r\n751–767.](http://onlinelibrary.wiley.com/doi/abs/10.1107/S0567739476001551)\r\n\r\n[Blundy, J., and Wood, B., 1994, Prediction of crystal–melt partition\r\ncoefficients from elastic moduli: Nature, v. 372, p.\r\n452–454.](https://www.nature.com/articles/372452a0)\r\n\r\n[McDonough, W. F., and Sun, S. -s., 1995, The composition of the Earth:\r\nChemical Geology, v. 120, p.\r\n223–253.](http://www.sciencedirect.com/science/article/pii/0009254194001404)\r\n\r\n[Ballard, J. R., Palin, M. J., and Campbell, I. H., 2002, Relative\r\noxidation states of magmas inferred from Ce(IV)/Ce(III) in zircon:\r\napplication to porphyry copper deposits of northern Chile: Contributions\r\nto Mineralogy and Petrology, v. 144, p.\r\n347–364.](http://link.springer.com/10.1007/s00410-002-0402-5)\r\n\r\n[Palme, H., and O’Neill, H. St. C., 2014, 3.1 - Cosmochemical Estimates\r\nof Mantle Composition, in Holland, H. D. and Turekian, K. K. eds.,\r\nTreatise on Geochemistry (Second Edition): Oxford, Elsevier, p.\r\n1–39.](http://www.sciencedirect.com/science/article/pii/B9780080959757002011)\r\n\r\n[Zhong, S., Seltmann, R., Qu, H., and Song, Y., 2019, Characterization\r\nof the zircon Ce anomaly for estimation of oxidation state of magmas: a\r\nrevised Ce/Ce\\* method: Mineralogy and Petrology, v. 113, no. 6,\r\np. 755–763.](https://link.springer.com/article/10.1007/s00710-019-00682-y)\r\n\r\n[Carrasco-Godoy, C., Campbell, I.H. Application of Onuma and lattice\r\nstrain derived methods to calculate missing REE and Ce and Eu anomalies\r\nin magmatic zircons. Contrib Mineral Petrol 178, 42 (2023).\r\nhttps://doi.org/10.1007/s00410-023-02025-9](https://link.springer.com/article/10.1007/s00410-023-02025-9)\r\n","type":"text"},{"name":"license.md","content":"\r\n# MIT License\r\n\r\nCopyright (c) 2023 Carlos Carrasco\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a\r\ncopy of this software and associated documentation files (the\r\n“Software”), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","type":"text"}]
